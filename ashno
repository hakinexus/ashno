#!/bin/bash
# ==============================================================================
#
# Ashno: The Professional Termux Toolkit Installer
#
# Version:      1.9.0 (Self-Healing & Flawless)
# Author:       hakinexus
# Description:  The definitive installer framework with a professional UI,
#               automatic dependency resolution, and robust error handling.
#
# ==============================================================================

# --- BOOTSTRAP: Ensure Core Dependencies Exist Before UI Starts ---
bootstrap_core() {
    # We need ncurses-utils for 'tput' (UI) and coreutils for basic logic
    local missing_deps=0
    if ! command -v tput &>/dev/null; then missing_deps=1; fi
    
    if [ $missing_deps -eq 1 ]; then
        echo "Initializing core dependencies for first run..."
        # Silently update and install ncurses-utils
        pkg update -y -o Dpkg::Options::="--force-confnew" &>/dev/null
        pkg install -y ncurses-utils coreutils &>/dev/null
    fi
}
bootstrap_core

# --- Globals and Configuration ---
readonly SCRIPT_NAME="Ashno"
readonly SCRIPT_PATH=$(readlink -f "$0")
readonly SCRIPT_DIR=$(dirname "$SCRIPT_PATH")
readonly PROFILES_DIR="$SCRIPT_DIR/profiles"
readonly LOG_DIR="$SCRIPT_DIR/logs"
LOG_FILE="" 

# --- ANSI Color Codes ---
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m';
BLUE='\033[0;34m'; PURPLE='\033[0;35m'; CYAN='\033[0;36m';
NC='\033[0m'; BOLD='\033[1m';

# --- UI Helper Wrappers (Fail-safe) ---
# These prevent the script from crashing if tput is somehow still missing
cursor_hide() { command -v tput &>/dev/null && tput civis; }
cursor_show() { command -v tput &>/dev/null && tput cnorm; }

# --- State-Tracking Variables ---
SUCCESS_LIST=(); FAILURE_LIST=(); SKIPPED_LIST=();
SELECTED_PROFILE=""

# --- Graceful Exit Handler ---
cleanup() { 
    echo -e "\n\n${YELLOW}SIGINT received. Shutting down gracefully.${NC}"
    cursor_show
    exit 130
}
trap cleanup INT TERM

# ==============================================================================
# SECTION: UI & CORE HELPER FUNCTIONS
# ==============================================================================
print_banner() {
    local title=" $1 "
    local inner_len=$((${#title} + 2))
    local border_line
    border_line=$(printf '─%.0s' $(seq 1 $inner_len))

    echo -e "\n${BLUE}╭─${border_line}─╮${NC}"
    echo -e "${BLUE}│  ${BOLD}${YELLOW}${title}${BLUE}  │${NC}"
    echo -e "${BLUE}╰─${border_line}─╯${NC}"
}

print_prompt() { echo -en "\n${CYAN}>${NC}${BOLD} Select an option:${NC} "; }

setup_logging() {
    mkdir -p "$LOG_DIR" || { echo -e "${RED}Fatal: Could not create log directory at ${LOG_DIR}${NC}"; exit 1; }
    LOG_FILE="${LOG_DIR}/ashno_$(date +'%Y%m%d-%H%M%S').log"
    {
        echo "Ashno Installation Log"
        echo "=========================================="
        echo "Date: $(date)"
        echo "Profile: ${SELECTED_PROFILE:-"N/A"}"
        echo "System: $(uname -a)"
        echo -e "\n"
    } > "$LOG_FILE"
}

print_help_menu() {
    clear; print_banner "Ashno Help Manual"
    echo -e "A professional, self-updating tool that installs packages from profiles."
    echo; echo -e "${BOLD}${YELLOW}USAGE:${NC}"; echo -e "  ashno ${PURPLE}[COMMANDS]${NC}"; echo -e "    Running without commands launches the interactive menu."
    echo; echo -e "${BOLD}${YELLOW}INSTALLATION COMMANDS:${NC}"
    printf "  ${PURPLE}%-20s${NC} %s\n" "--profile <NAME>" "Required. Selects a profile by its directory name."
    printf "  ${PURPLE}%-20s${NC} %s\n" "--all | --pkg | ..." "Required. The action to perform (install all, pkg, etc.)."
    echo; echo -e "${BOLD}${YELLOW}UTILITY COMMANDS:${NC}"
    printf "  ${PURPLE}%-20s${NC} %s\n" "-u, --update" "Checks for and applies updates to Ashno itself."
    printf "  ${PURPLE}%-20s${NC} %s\n" "-h, --help" "Display this help manual and exit."
    echo; echo -e "${BOLD}${YELLOW}EXAMPLE:${NC}"; echo -e "  ashno --profile 2_extended --all"; echo
}

build_package_list() {
    local pkg_type="$1"; local sel_prof_name="$2"; local f_list=""; local f_read=();
    # Logic to handle cumulative profiles (1...N)
    if [[ "$sel_prof_name" =~ ^([0-9]+)_.+ ]]; then 
        local p_lvl="${BASH_REMATCH[1]}"
        for i in $(seq 1 "$p_lvl"); do 
            local f_dir; f_dir=$(find "$PROFILES_DIR" -maxdepth 1 -type d -name "${i}_*" | head -n 1)
            if [ -n "$f_dir" ]; then 
                local l_file="${f_dir}/${pkg_type}.list"
                if [ -f "$l_file" ]; then f_read+=("$l_file"); fi
            fi
        done
    else 
        local l_file="${PROFILES_DIR}/${sel_prof_name}/${pkg_type}.list"
        if [ -f "$l_file" ]; then f_read+=("$l_file"); fi
    fi
    
    if [ ${#f_read[@]} -gt 0 ]; then 
        # Clean input: remove comments, empty lines, and Carriage Returns (for Windows-edited files)
        cat "${f_read[@]}" | tr -d '\r' | grep -vE '^\s*#|^\s*$' | sort -u
    fi
}

# ==============================================================================
# SECTION: SELF-UPDATE MECHANISM
# ==============================================================================
handle_updates() {
    local mode="$1"
    if [ ! -d ".git" ]; then return 0; fi # Skip if not a git repo
    
    cd "$SCRIPT_DIR" || return 1
    if [ "$mode" == "manual" ]; then print_banner "Ashno Updater"; fi
    echo -en "  Checking for updates..."
    
    git fetch origin &>/dev/null
    if [ $? -ne 0 ]; then printf "\r\033[K"; echo -e "  ${RED}✖${NC} Could not fetch updates (Network issue?)."; return 1; fi
    
    local local_rev; local_rev=$(git rev-parse HEAD)
    local remote_rev; remote_rev=$(git rev-parse '@{u}')
    
    if [ "$local_rev" == "$remote_rev" ]; then 
        printf "\r\033[K"
        if [ "$mode" == "manual" ]; then echo -e "  ${GREEN}✔${NC} Ashno is already up to date."; fi
        return 0
    fi
    
    printf "\r\033[K"; echo -e "  ${YELLOW}●${NC} An update is available for Ashno!"
    if ! git diff-index --quiet HEAD --; then 
        echo -e "  ${RED}✖${NC} Update aborted. Local changes detected."; 
        [ "$mode" == "auto" ] && exit 1 || return 1
    fi
    
    local prompt_msg="Do you want to apply the update now? [Y/n]: "
    [ "$mode" == "auto" ] && prompt_msg="Update required. Apply now? [Y/n]: "
    
    read -p "  ${prompt_msg}" choice
    case "$choice" in
        [nN][oO]) echo -e "  Update cancelled."; [ "$mode" == "auto" ] && exit 1 || return 1 ;;
        *) echo -en "  Applying update..."; git pull origin main &>/dev/null
           printf "\r\033[K"; echo -e "  ${GREEN}✔${NC} Ashno updated. Restarting...";
           exec "$0" "$@" ;; # Restart script with same args
    esac
}

# ==============================================================================
# SECTION: INSTALLATION ENGINE
# ==============================================================================
spinner() {
    cursor_hide
    local pid=$1
    local str='⣾⣽⣻⢿⡿⣟⣯⣷'
    while kill -0 "$pid" 2>/dev/null; do
        printf "${PURPLE}%s${NC}" "${str:0:1}"
        str=${str:1}${str:0:1}
        sleep 0.08
        printf "\b"
    done
    printf " "
    cursor_show
}

pre_flight_checks() { 
    print_banner "Performing System Checks"
    if ! ping -c 1 8.8.8.8 &>/dev/null; then echo -e " ${RED}✖${NC} Internet: Disconnected"; exit 1; fi
    echo -e " ${GREEN}✔${NC} Internet Connection: OK"
    
    # Check Termux Storage Access
    if [ ! -d ~/storage ]; then
        echo -e " ${YELLOW}!${NC} Requesting Storage Access..."
        termux-setup-storage
    fi
}

update_termux() { 
    print_banner "Updating Termux Base System"
    # Running pkg update in background
    (pkg update -y -o Dpkg::Options::="--force-confnew" && pkg upgrade -y -o Dpkg::Options::="--force-confnew") &>/dev/null & 
    local pid=$!
    echo -en "  Updating sources and packages... "
    spinner $pid
    wait $pid
    printf "\r\033[K"
    echo -e " ${GREEN}✔${NC} Base system update complete."
}

_process_package_list() {
    local CMD_CHECK="$1"; local INSTALL_CMD="$2"; shift 2; local package_list=("$@")
    for pkg_name in "${package_list[@]}"; do
        # Trim whitespace
        pkg_name=$(echo "$pkg_name" | xargs)
        [ -z "$pkg_name" ] && continue

        if $CMD_CHECK "$pkg_name" &>/dev/null; then
            SKIPPED_LIST+=("$pkg_name")
            echo -e " ${YELLOW}●${NC} ${pkg_name} (already installed)"
        else
            local error_log; error_log=$(mktemp)
            echo -en "  Installing ${BOLD}${pkg_name}${NC}... "
            
            ($INSTALL_CMD "$pkg_name") >/dev/null 2>"$error_log" & 
            local pid=$!
            spinner $pid
            wait $pid
            local exit_code=$?
            printf "\r\033[K"

            if [ "$exit_code" -eq 0 ]; then
                echo -e " ${GREEN}✔${NC}  ${pkg_name}"
                SUCCESS_LIST+=("$pkg_name")
            else
                echo -e " ${RED}✖${NC}  ${pkg_name}"
                FAILURE_LIST+=("$pkg_name")
                {
                    echo "-------------------------------------------------"
                    echo "[FAIL] Package Install: '$pkg_name' at $(date)"
                    echo "-------------------------------------------------"
                    cat "$error_log"
                    echo -e "\n"
                } >> "$LOG_FILE"
            fi
            rm -f "$error_log"
        fi
    done
}

install_pkg() {
    print_banner "Installing PKG Packages"
    local package_list; package_list=$(build_package_list "pkg" "$SELECTED_PROFILE")
    if [ -z "$package_list" ]; then echo "No PKG packages found in this profile."; return; fi
    local list_array; readarray -t list_array <<< "$package_list"
    _process_package_list "dpkg -s" "pkg install -y" "${list_array[@]}"
}

install_npm() {
    print_banner "Installing NPM Packages"
    if ! command -v npm &>/dev/null; then 
        echo -e "${YELLOW}Notification:${NC} NPM not found. Installing Node.js first..."
        pkg install -y nodejs &>/dev/null
    fi
    local package_list; package_list=$(build_package_list "npm" "$SELECTED_PROFILE")
    if [ -z "$package_list" ]; then echo "No NPM packages found in this profile."; return; fi
    local list_array; readarray -t list_array <<< "$package_list"
    _process_package_list "npm list -g --depth=0" "npm install -g" "${list_array[@]}"
}

install_pip() {
    print_banner "Installing PIP Packages"
    if ! command -v pip &>/dev/null; then 
        echo -e "${YELLOW}Notification:${NC} PIP not found. Installing Python first..."
        pkg install -y python &>/dev/null
    fi
    echo -en "  Upgrading PIP core... "
    (pip install --upgrade pip setuptools wheel) &>/dev/null & spinner $!; wait $!
    printf "\r\033[K"
    
    local package_list; package_list=$(build_package_list "pip" "$SELECTED_PROFILE")
    if [ -z "$package_list" ]; then echo "No PIP packages found in this profile."; return; fi
    local list_array; readarray -t list_array <<< "$package_list"
    _process_package_list "pip show" "pip install --no-cache-dir" "${list_array[@]}"
}

# ==============================================================================
# SECTION: MENUS & REPORTING
# ==============================================================================
print_summary_report() {
    print_banner "Installation Summary Report"
    echo -e " Summary of all installation operations."; echo
    echo -e " ${GREEN}✔ Successful: ${#SUCCESS_LIST[@]}${NC}"
    echo -e " ${RED}✖ Failed:     ${#FAILURE_LIST[@]}${NC}"
    echo -e " ${YELLOW}● Skipped:    ${#SKIPPED_LIST[@]}${NC}"

    if [ ${#FAILURE_LIST[@]} -gt 0 ]; then
        echo; echo -e "${YELLOW}NOTE:${NC} Errors occurred. Check the log file:"
        echo -e "      ${BOLD}${LOG_FILE}${NC}"
    fi
    echo -e "\n${GREEN}${BOLD}Operation Complete.${NC}"
}

main_menu() {
    clear; print_banner "Main Menu"
    echo -e "  ${BOLD}Active Profile:${NC} ${YELLOW}${SELECTED_PROFILE}${NC}\n"
    echo -e "  ${CYAN}1)${NC}  ${BOLD}Full Installation${NC} (PKG, NPM, PIP)"
    echo -e "  ${CYAN}2)${NC}  Install ${BOLD}PKG${NC} Packages"
    echo -e "  ${CYAN}3)${NC}  Install ${BOLD}NPM${NC} Packages"
    echo -e "  ${CYAN}4)${NC}  Install ${BOLD}PIP${NC} Packages"
    echo; echo -e "  ${CYAN}5)${NC}  Change Profile"
    echo -e "  ${CYAN}6)${NC}  Exit Ashno"
}

profile_selection_menu() {
    clear; print_banner "Choose Installation Profile"
    local profiles=(); while IFS= read -r line; do profiles+=("$line"); done < <(find "$PROFILES_DIR" -maxdepth 1 -mindepth 1 -type d | sort)
    
    if [ ${#profiles[@]} -eq 0 ]; then echo -e "${RED}Error: No profiles found in '${PROFILES_DIR}/'.${NC}"; exit 1; fi
    
    echo -e "Welcome to Ashno. Please select a profile to begin.\n"
    local count=1
    for profile_path in "${profiles[@]}"; do
        local profile_name; profile_name=$(basename "$profile_path")
        local option_line
        case "$profile_name" in
            "1_essentials") option_line=$(printf "  ${CYAN}%2d)${NC} ${BOLD}Essentials${NC}" "$count") ;;
            "2_extended")   option_line=$(printf "  ${CYAN}%2d)${NC} ${BOLD}Extended${NC} ${GREEN}(Recommended)${NC}" "$count") ;;
            "3_complete")   option_line=$(printf "  ${CYAN}%2d)${NC} ${BOLD}Complete${NC}" "$count") ;;
            *)              option_line=$(printf "  ${CYAN}%2d)${NC} ${BOLD}%s${NC}" "$count" "$profile_name") ;;
        esac
        echo -e "$option_line"
        count=$((count + 1))
    done
    printf "  ${CYAN}%2d)${NC} ${BOLD}%s${NC}\n" "$count" "Exit Ashno"
    
    local choice; print_prompt; read choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#profiles[@]} ]; then 
        SELECTED_PROFILE=$(basename "${profiles[$choice-1]}")
    elif [ "$choice" -eq $count ]; then 
        echo -e "\nExiting Ashno."; exit 0
    else 
        echo -e "\n${RED}Invalid selection.${NC}"; sleep 1; profile_selection_menu
    fi
}

# ==============================================================================
# SECTION: EXECUTION ENTRYPOINT
# ==============================================================================
if [ ! -d "$PROFILES_DIR" ]; then echo -e "${RED}Fatal Error: '${PROFILES_DIR}/' not found.${NC}"; exit 1; fi

# --- Non-Interactive Mode ---
if [ $# -gt 0 ]; then
    profile_arg=""; action_arg=""
    while [ $# -gt 0 ]; do
        case "$1" in 
            -h|--help) print_help_menu; exit 0;; 
            -u|--update) handle_updates "manual"; exit 0;; 
            --profile) profile_arg="$2"; shift 2;; 
            --all|--pkg|--npm|--pip) action_arg="$1"; shift 1;; 
            *) echo -e "${RED}Invalid argument: $1${NC}\nUse 'ashno --help'."; exit 1;; 
        esac
    done
    
    if [ -z "$profile_arg" ] || [ -z "$action_arg" ] || [ ! -d "${PROFILES_DIR}/${profile_arg}" ]; then 
        echo -e "${RED}Error: Valid --profile and action required.${NC}"; exit 1
    fi
    
    SELECTED_PROFILE=$profile_arg
    setup_logging; pre_flight_checks; handle_updates "auto"
    
    [ "$action_arg" == "--all" ] || [ "$action_arg" == "--pkg" ] && { update_termux; install_pkg; }
    [ "$action_arg" == "--all" ] || [ "$action_arg" == "--npm" ] && install_npm
    [ "$action_arg" == "--all" ] || [ "$action_arg" == "--pip" ] && install_pip
    
    print_summary_report; exit 0
fi

# --- Interactive Mode ---
clear; handle_updates "auto"; profile_selection_menu
pre_flight_checks
setup_logging
while true; do
    main_menu; print_prompt; read main_choice
    case $main_choice in
        1) update_termux; install_pkg; install_npm; install_pip;;
        2) update_termux; install_pkg;;
        3) install_npm;;
        4) install_pip;;
        5) profile_selection_menu; setup_logging; continue;;
        6) echo -e "\nExiting Ashno."; exit 0;;
        *) echo -e "\n${RED}Invalid choice.${NC}"; sleep 1; continue;;
    esac
    print_summary_report; echo; read -n 1 -s -r -p "Press any key to return to the main menu..."
    SUCCESS_LIST=(); FAILURE_LIST=(); SKIPPED_LIST=();
done
